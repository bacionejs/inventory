<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Inventory</title>
<style>
body{font-family:sans-serif;margin:0;padding:10px;font-size:18px}
table{border-collapse:collapse;margin-top:10px;width:100%;font-size:18px}
td,th{border:1px solid #aaa;padding:1px}

/* --- NEW CSS FOR EDITABLE CELLS --- */
td[contenteditable="true"] {
  outline: 1px dashed #007bff; 
  padding: 8px; 
}

/* Style for the input field used with datalist (combobox) */
input.combobox {
  padding: 7px 0;
  font-size: 18px;
  width: 100%;
  box-sizing: border-box;
  border: none;
}

td.small-cell {
    width: 50px;
    text-align: left;
}

td.id-cell {
    width: 50px;
    text-align: center;
}
/* --- END NEW CSS --- */

button{padding:8px 12px;font-size:20px;
cursor:pointer}
button + button{margin-left:6px}
td.action{white-space:nowrap}
#topButtons{margin-bottom:10px}
</style>
</head>
<body>

<h2>Inventory</h2>

<div id="topButtons">
  <button id="updateAllBtn">üíæ Update All</button> <button id="exportBtn">üì§ Export</button>
  <button id="importBtn">üì• Import</button>
  <button id="clearBtn">üóëÔ∏è Clear DB</button>
  <input type="file" id="importFile" style="display:none" accept=".json">
</div>

<table id="tbl">
  <tr>
    <th>ID</th><th>Name</th><th>Model</th><th>Price</th><th>Qty</th><th>Action</th>
  </tr>
</table>

<script>
let uniqueNames = [];
let allRecords = []; // Global array to store current DB records, needed for update logic

// --- OPEN DATABASE ---
let db;
let req = indexedDB.open("inventoryDB", 1);
req.onupgradeneeded = e => {
  db = e.target.result;
  if(!db.objectStoreNames.contains("items")) {
    db.createObjectStore("items", { keyPath: "id", autoIncrement: true });
  }
};
req.onsuccess = e => { db = e.target.result; load(); };

// --- LOAD RECORDS (MODIFIED to store records globally) ---
function load(){
  let tbl = document.getElementById("tbl");
  while(tbl.rows.length > 1) tbl.deleteRow(1);
  
  allRecords = []; // Clear global records array
  let tx = db.transaction("items", "readonly");
  let store = tx.objectStore("items");
  
  let cursorReq = store.openCursor();
  
  cursorReq.onsuccess = e => {
      let cursor = e.target.result;
      if (cursor) {
          allRecords.push(cursor.value);
          cursor.continue();
      } else {
          // Finished reading records
          // 1. Extract unique names
          uniqueNames = [...new Set(allRecords.map(item => item.name).filter(name => name))].sort();
          
          // 2. Add existing rows
          allRecords.forEach(item => addRow(item, false));
          
          // 3. Add blank add row (The submit row)
          addRow(null, true); 
      }
  };
}

// --- UPDATE ALL FUNCTION (NEW) ---
document.getElementById("updateAllBtn").onclick = updateAll;

function updateAll() {
    let tbl = document.getElementById("tbl");
    // All updates/inserts must happen in a single transaction
    let tx = db.transaction("items", "readwrite");
    let store = tx.objectStore("items");
    let itemsToProcess = [];

    // 1. Process all existing rows and the single new row
    for (let i = 1; i < tbl.rows.length; i++) {
        let tr = tbl.rows[i];
        let isNewRow = (i === tbl.rows.length - 1);
        let originalData = isNewRow ? null : allRecords[i - 1]; // Use stored data for original ID
        
        // Helper function to get value from TD (editable) or INPUT (combobox)
        function getCellValue(index) {
            let cell = tr.cells[index];
            if (cell.children.length > 0 && cell.children[0].tagName === 'INPUT') {
                return cell.children[0].value.trim();
            }
            return cell.textContent.trim();
        }

        // Gather all data from the cells
        let nameValue = getCellValue(1); // Name is column index 1
        
        let obj = {
            name: nameValue,
            model: getCellValue(2),
            price: parseFloat(getCellValue(3)) || 0,
            quantity: parseInt(getCellValue(4) || "0", 10) || 0 
        };
        
        // Skip empty new item row submission
        if (isNewRow && !obj.name && !obj.model) {
            continue; 
        }

        if (isNewRow) {
            // New Item: Use store.add (ID is auto-generated)
            store.add(obj);
        } else {
            // Existing Item: Check for ID change
            const originalId = originalData.id;
            const newIdText = tr.cells[0].textContent;
            const newId = parseInt(newIdText) || originalId;

            if (newId !== originalId) {
                // ID changed: Delete old, add new
                store.delete(originalId);
                obj.id = newId;
                store.add(obj);
            } else {
                // ID unchanged: Standard update
                obj.id = originalId;
                store.put(obj);
            }
        }
    }
    
    // 2. Monitor Transaction Completion
    tx.oncomplete = load;
    tx.onerror = (e) => {
        alert("Error saving records. One of the manually entered IDs might already exist or be invalid.");
        console.error("TX Error:", e);
        load();
    };
}


// --- BUILD ONE ROW (MODIFIED: Remove update button logic) ---
function addRow(data, isNewRow){
  let tr = document.createElement("tr");
  let fields = ["id", "name", "model", "price", "quantity"];
  let inputElements = {}; // Still useful for reference but not strictly needed for updateAll

  fields.forEach(f => {
    let td = document.createElement("td");
    
    if (f === "id") {
        td.textContent = data ? data[f] : "";
        td.classList.add("id-cell");
        
        if (!isNewRow) {
            td.contentEditable = "true";
        }
        inputElements[f] = td;
        
    } else if (f === "name" && isNewRow) {
      // Datalist/Combobox for new row Name
      let input = document.createElement("input");
      input.type = "text";
      input.classList.add("combobox");
      let listId = "name_options";
      input.setAttribute("list", listId); 

      let datalist = document.createElement("datalist");
      datalist.id = listId;

      uniqueNames.forEach(name => {
        let option = document.createElement("option");
        option.value = name;
        datalist.appendChild(option);
      });
      
      td.appendChild(input);
      td.appendChild(datalist);
      inputElements[f] = input;
      
    } else {
      // Editable TD for existing rows and other fields
      td.textContent = data ? data[f] : "";
      td.contentEditable = "true";
      
      if(f === "price" || f === "quantity") {
        td.classList.add("small-cell");
      }
      
      inputElements[f] = td;
    }

    tr.appendChild(td);
  });

  let actionCell = document.createElement("td");
  actionCell.className = "action";

  // REMOVED: mainBtn (Update/Submit) logic
  
  if(data){
    let del = document.createElement("button");
    del.textContent = "‚ùå";
    del.title = "Delete";
    del.onclick = () => {
      if(!confirm("Delete this item?")) return;
      let tx = db.transaction("items", "readwrite");
      tx.objectStore("items").delete(data.id);
      tx.oncomplete = load;
    };
    actionCell.appendChild(del);
  }

  tr.appendChild(actionCell);
  document.getElementById("tbl").appendChild(tr);
}

// --- EXPORT, IMPORT, CLEAR DB functions remain unchanged ---

document.getElementById("exportBtn").onclick = () => {
  let tx = db.transaction("items", "readonly");
  tx.objectStore("items").getAll().onsuccess = e => {
    let data = e.target.result;
    let blob = new Blob([JSON.stringify(data, null, 2)], {type:"application/json"});
    let url = URL.createObjectURL(blob);
    let a = document.createElement("a");
    a.href = url;
    a.download = "inventory.json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };
};

document.getElementById("importBtn").onclick = () => {
  document.getElementById("importFile").click();
};

document.getElementById("importFile").onchange = e => {
  let file = e.target.files[0];
  if(!file) return;
  let reader = new FileReader();
  reader.onload = evt => {
    try {
      let items = JSON.parse(evt.target.result);
      let tx = db.transaction("items", "readwrite");
      let store = tx.objectStore("items");
      items.forEach(item => {
        let copy = {...item};
        delete copy.id;
        store.add(copy);
      });
      tx.oncomplete = load;
    } catch(err) {
      alert("Invalid JSON file");
      console.error(err);
    }
  };
  reader.readAsText(file);
};

document.getElementById("clearBtn").onclick = () => {
  if(!confirm("Are you sure you want to clear the entire database?")) return;
  let tx = db.transaction("items", "readwrite");
  tx.objectStore("items").clear();
  tx.oncomplete = load;
};
</script>

</body>
</html>

